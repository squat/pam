// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: authzed/api/v1/schema_service.proto

package v1

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on ReadSchemaRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ReadSchemaRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ReadSchemaRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ReadSchemaRequestMultiError, or nil if none found.
func (m *ReadSchemaRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ReadSchemaRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return ReadSchemaRequestMultiError(errors)
	}

	return nil
}

// ReadSchemaRequestMultiError is an error wrapping multiple validation errors
// returned by ReadSchemaRequest.ValidateAll() if the designated constraints
// aren't met.
type ReadSchemaRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ReadSchemaRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ReadSchemaRequestMultiError) AllErrors() []error { return m }

// ReadSchemaRequestValidationError is the validation error returned by
// ReadSchemaRequest.Validate if the designated constraints aren't met.
type ReadSchemaRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ReadSchemaRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ReadSchemaRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ReadSchemaRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ReadSchemaRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ReadSchemaRequestValidationError) ErrorName() string {
	return "ReadSchemaRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ReadSchemaRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sReadSchemaRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ReadSchemaRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ReadSchemaRequestValidationError{}

// Validate checks the field values on ReadSchemaResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ReadSchemaResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ReadSchemaResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ReadSchemaResponseMultiError, or nil if none found.
func (m *ReadSchemaResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ReadSchemaResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for SchemaText

	if m.GetReadAt() == nil {
		err := ReadSchemaResponseValidationError{
			field:  "ReadAt",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetReadAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ReadSchemaResponseValidationError{
					field:  "ReadAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ReadSchemaResponseValidationError{
					field:  "ReadAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetReadAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ReadSchemaResponseValidationError{
				field:  "ReadAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ReadSchemaResponseMultiError(errors)
	}

	return nil
}

// ReadSchemaResponseMultiError is an error wrapping multiple validation errors
// returned by ReadSchemaResponse.ValidateAll() if the designated constraints
// aren't met.
type ReadSchemaResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ReadSchemaResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ReadSchemaResponseMultiError) AllErrors() []error { return m }

// ReadSchemaResponseValidationError is the validation error returned by
// ReadSchemaResponse.Validate if the designated constraints aren't met.
type ReadSchemaResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ReadSchemaResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ReadSchemaResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ReadSchemaResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ReadSchemaResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ReadSchemaResponseValidationError) ErrorName() string {
	return "ReadSchemaResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ReadSchemaResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sReadSchemaResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ReadSchemaResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ReadSchemaResponseValidationError{}

// Validate checks the field values on WriteSchemaRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *WriteSchemaRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on WriteSchemaRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// WriteSchemaRequestMultiError, or nil if none found.
func (m *WriteSchemaRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *WriteSchemaRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(m.GetSchema()) > 4194304 {
		err := WriteSchemaRequestValidationError{
			field:  "Schema",
			reason: "value length must be at most 4194304 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return WriteSchemaRequestMultiError(errors)
	}

	return nil
}

// WriteSchemaRequestMultiError is an error wrapping multiple validation errors
// returned by WriteSchemaRequest.ValidateAll() if the designated constraints
// aren't met.
type WriteSchemaRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m WriteSchemaRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m WriteSchemaRequestMultiError) AllErrors() []error { return m }

// WriteSchemaRequestValidationError is the validation error returned by
// WriteSchemaRequest.Validate if the designated constraints aren't met.
type WriteSchemaRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e WriteSchemaRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e WriteSchemaRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e WriteSchemaRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e WriteSchemaRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e WriteSchemaRequestValidationError) ErrorName() string {
	return "WriteSchemaRequestValidationError"
}

// Error satisfies the builtin error interface
func (e WriteSchemaRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sWriteSchemaRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = WriteSchemaRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = WriteSchemaRequestValidationError{}

// Validate checks the field values on WriteSchemaResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *WriteSchemaResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on WriteSchemaResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// WriteSchemaResponseMultiError, or nil if none found.
func (m *WriteSchemaResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *WriteSchemaResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetWrittenAt() == nil {
		err := WriteSchemaResponseValidationError{
			field:  "WrittenAt",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetWrittenAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, WriteSchemaResponseValidationError{
					field:  "WrittenAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, WriteSchemaResponseValidationError{
					field:  "WrittenAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetWrittenAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return WriteSchemaResponseValidationError{
				field:  "WrittenAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return WriteSchemaResponseMultiError(errors)
	}

	return nil
}

// WriteSchemaResponseMultiError is an error wrapping multiple validation
// errors returned by WriteSchemaResponse.ValidateAll() if the designated
// constraints aren't met.
type WriteSchemaResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m WriteSchemaResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m WriteSchemaResponseMultiError) AllErrors() []error { return m }

// WriteSchemaResponseValidationError is the validation error returned by
// WriteSchemaResponse.Validate if the designated constraints aren't met.
type WriteSchemaResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e WriteSchemaResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e WriteSchemaResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e WriteSchemaResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e WriteSchemaResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e WriteSchemaResponseValidationError) ErrorName() string {
	return "WriteSchemaResponseValidationError"
}

// Error satisfies the builtin error interface
func (e WriteSchemaResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sWriteSchemaResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = WriteSchemaResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = WriteSchemaResponseValidationError{}

// Validate checks the field values on ReflectSchemaRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ReflectSchemaRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ReflectSchemaRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ReflectSchemaRequestMultiError, or nil if none found.
func (m *ReflectSchemaRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ReflectSchemaRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetConsistency()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ReflectSchemaRequestValidationError{
					field:  "Consistency",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ReflectSchemaRequestValidationError{
					field:  "Consistency",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetConsistency()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ReflectSchemaRequestValidationError{
				field:  "Consistency",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetOptionalFilters() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ReflectSchemaRequestValidationError{
						field:  fmt.Sprintf("OptionalFilters[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ReflectSchemaRequestValidationError{
						field:  fmt.Sprintf("OptionalFilters[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ReflectSchemaRequestValidationError{
					field:  fmt.Sprintf("OptionalFilters[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ReflectSchemaRequestMultiError(errors)
	}

	return nil
}

// ReflectSchemaRequestMultiError is an error wrapping multiple validation
// errors returned by ReflectSchemaRequest.ValidateAll() if the designated
// constraints aren't met.
type ReflectSchemaRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ReflectSchemaRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ReflectSchemaRequestMultiError) AllErrors() []error { return m }

// ReflectSchemaRequestValidationError is the validation error returned by
// ReflectSchemaRequest.Validate if the designated constraints aren't met.
type ReflectSchemaRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ReflectSchemaRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ReflectSchemaRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ReflectSchemaRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ReflectSchemaRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ReflectSchemaRequestValidationError) ErrorName() string {
	return "ReflectSchemaRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ReflectSchemaRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sReflectSchemaRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ReflectSchemaRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ReflectSchemaRequestValidationError{}

// Validate checks the field values on ReflectSchemaResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ReflectSchemaResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ReflectSchemaResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ReflectSchemaResponseMultiError, or nil if none found.
func (m *ReflectSchemaResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ReflectSchemaResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetDefinitions() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ReflectSchemaResponseValidationError{
						field:  fmt.Sprintf("Definitions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ReflectSchemaResponseValidationError{
						field:  fmt.Sprintf("Definitions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ReflectSchemaResponseValidationError{
					field:  fmt.Sprintf("Definitions[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetCaveats() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ReflectSchemaResponseValidationError{
						field:  fmt.Sprintf("Caveats[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ReflectSchemaResponseValidationError{
						field:  fmt.Sprintf("Caveats[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ReflectSchemaResponseValidationError{
					field:  fmt.Sprintf("Caveats[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetReadAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ReflectSchemaResponseValidationError{
					field:  "ReadAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ReflectSchemaResponseValidationError{
					field:  "ReadAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetReadAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ReflectSchemaResponseValidationError{
				field:  "ReadAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ReflectSchemaResponseMultiError(errors)
	}

	return nil
}

// ReflectSchemaResponseMultiError is an error wrapping multiple validation
// errors returned by ReflectSchemaResponse.ValidateAll() if the designated
// constraints aren't met.
type ReflectSchemaResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ReflectSchemaResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ReflectSchemaResponseMultiError) AllErrors() []error { return m }

// ReflectSchemaResponseValidationError is the validation error returned by
// ReflectSchemaResponse.Validate if the designated constraints aren't met.
type ReflectSchemaResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ReflectSchemaResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ReflectSchemaResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ReflectSchemaResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ReflectSchemaResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ReflectSchemaResponseValidationError) ErrorName() string {
	return "ReflectSchemaResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ReflectSchemaResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sReflectSchemaResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ReflectSchemaResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ReflectSchemaResponseValidationError{}

// Validate checks the field values on ReflectionSchemaFilter with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ReflectionSchemaFilter) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ReflectionSchemaFilter with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ReflectionSchemaFilterMultiError, or nil if none found.
func (m *ReflectionSchemaFilter) ValidateAll() error {
	return m.validate(true)
}

func (m *ReflectionSchemaFilter) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for OptionalDefinitionNameFilter

	// no validation rules for OptionalCaveatNameFilter

	// no validation rules for OptionalRelationNameFilter

	// no validation rules for OptionalPermissionNameFilter

	if len(errors) > 0 {
		return ReflectionSchemaFilterMultiError(errors)
	}

	return nil
}

// ReflectionSchemaFilterMultiError is an error wrapping multiple validation
// errors returned by ReflectionSchemaFilter.ValidateAll() if the designated
// constraints aren't met.
type ReflectionSchemaFilterMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ReflectionSchemaFilterMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ReflectionSchemaFilterMultiError) AllErrors() []error { return m }

// ReflectionSchemaFilterValidationError is the validation error returned by
// ReflectionSchemaFilter.Validate if the designated constraints aren't met.
type ReflectionSchemaFilterValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ReflectionSchemaFilterValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ReflectionSchemaFilterValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ReflectionSchemaFilterValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ReflectionSchemaFilterValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ReflectionSchemaFilterValidationError) ErrorName() string {
	return "ReflectionSchemaFilterValidationError"
}

// Error satisfies the builtin error interface
func (e ReflectionSchemaFilterValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sReflectionSchemaFilter.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ReflectionSchemaFilterValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ReflectionSchemaFilterValidationError{}

// Validate checks the field values on ReflectionDefinition with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ReflectionDefinition) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ReflectionDefinition with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ReflectionDefinitionMultiError, or nil if none found.
func (m *ReflectionDefinition) ValidateAll() error {
	return m.validate(true)
}

func (m *ReflectionDefinition) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	// no validation rules for Comment

	for idx, item := range m.GetRelations() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ReflectionDefinitionValidationError{
						field:  fmt.Sprintf("Relations[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ReflectionDefinitionValidationError{
						field:  fmt.Sprintf("Relations[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ReflectionDefinitionValidationError{
					field:  fmt.Sprintf("Relations[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetPermissions() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ReflectionDefinitionValidationError{
						field:  fmt.Sprintf("Permissions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ReflectionDefinitionValidationError{
						field:  fmt.Sprintf("Permissions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ReflectionDefinitionValidationError{
					field:  fmt.Sprintf("Permissions[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ReflectionDefinitionMultiError(errors)
	}

	return nil
}

// ReflectionDefinitionMultiError is an error wrapping multiple validation
// errors returned by ReflectionDefinition.ValidateAll() if the designated
// constraints aren't met.
type ReflectionDefinitionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ReflectionDefinitionMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ReflectionDefinitionMultiError) AllErrors() []error { return m }

// ReflectionDefinitionValidationError is the validation error returned by
// ReflectionDefinition.Validate if the designated constraints aren't met.
type ReflectionDefinitionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ReflectionDefinitionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ReflectionDefinitionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ReflectionDefinitionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ReflectionDefinitionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ReflectionDefinitionValidationError) ErrorName() string {
	return "ReflectionDefinitionValidationError"
}

// Error satisfies the builtin error interface
func (e ReflectionDefinitionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sReflectionDefinition.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ReflectionDefinitionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ReflectionDefinitionValidationError{}

// Validate checks the field values on ReflectionCaveat with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ReflectionCaveat) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ReflectionCaveat with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ReflectionCaveatMultiError, or nil if none found.
func (m *ReflectionCaveat) ValidateAll() error {
	return m.validate(true)
}

func (m *ReflectionCaveat) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	// no validation rules for Comment

	for idx, item := range m.GetParameters() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ReflectionCaveatValidationError{
						field:  fmt.Sprintf("Parameters[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ReflectionCaveatValidationError{
						field:  fmt.Sprintf("Parameters[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ReflectionCaveatValidationError{
					field:  fmt.Sprintf("Parameters[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for Expression

	if len(errors) > 0 {
		return ReflectionCaveatMultiError(errors)
	}

	return nil
}

// ReflectionCaveatMultiError is an error wrapping multiple validation errors
// returned by ReflectionCaveat.ValidateAll() if the designated constraints
// aren't met.
type ReflectionCaveatMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ReflectionCaveatMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ReflectionCaveatMultiError) AllErrors() []error { return m }

// ReflectionCaveatValidationError is the validation error returned by
// ReflectionCaveat.Validate if the designated constraints aren't met.
type ReflectionCaveatValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ReflectionCaveatValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ReflectionCaveatValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ReflectionCaveatValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ReflectionCaveatValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ReflectionCaveatValidationError) ErrorName() string { return "ReflectionCaveatValidationError" }

// Error satisfies the builtin error interface
func (e ReflectionCaveatValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sReflectionCaveat.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ReflectionCaveatValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ReflectionCaveatValidationError{}

// Validate checks the field values on ReflectionCaveatParameter with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ReflectionCaveatParameter) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ReflectionCaveatParameter with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ReflectionCaveatParameterMultiError, or nil if none found.
func (m *ReflectionCaveatParameter) ValidateAll() error {
	return m.validate(true)
}

func (m *ReflectionCaveatParameter) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	// no validation rules for Type

	// no validation rules for ParentCaveatName

	if len(errors) > 0 {
		return ReflectionCaveatParameterMultiError(errors)
	}

	return nil
}

// ReflectionCaveatParameterMultiError is an error wrapping multiple validation
// errors returned by ReflectionCaveatParameter.ValidateAll() if the
// designated constraints aren't met.
type ReflectionCaveatParameterMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ReflectionCaveatParameterMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ReflectionCaveatParameterMultiError) AllErrors() []error { return m }

// ReflectionCaveatParameterValidationError is the validation error returned by
// ReflectionCaveatParameter.Validate if the designated constraints aren't met.
type ReflectionCaveatParameterValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ReflectionCaveatParameterValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ReflectionCaveatParameterValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ReflectionCaveatParameterValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ReflectionCaveatParameterValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ReflectionCaveatParameterValidationError) ErrorName() string {
	return "ReflectionCaveatParameterValidationError"
}

// Error satisfies the builtin error interface
func (e ReflectionCaveatParameterValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sReflectionCaveatParameter.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ReflectionCaveatParameterValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ReflectionCaveatParameterValidationError{}

// Validate checks the field values on ReflectionRelation with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ReflectionRelation) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ReflectionRelation with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ReflectionRelationMultiError, or nil if none found.
func (m *ReflectionRelation) ValidateAll() error {
	return m.validate(true)
}

func (m *ReflectionRelation) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	// no validation rules for Comment

	// no validation rules for ParentDefinitionName

	for idx, item := range m.GetSubjectTypes() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ReflectionRelationValidationError{
						field:  fmt.Sprintf("SubjectTypes[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ReflectionRelationValidationError{
						field:  fmt.Sprintf("SubjectTypes[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ReflectionRelationValidationError{
					field:  fmt.Sprintf("SubjectTypes[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ReflectionRelationMultiError(errors)
	}

	return nil
}

// ReflectionRelationMultiError is an error wrapping multiple validation errors
// returned by ReflectionRelation.ValidateAll() if the designated constraints
// aren't met.
type ReflectionRelationMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ReflectionRelationMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ReflectionRelationMultiError) AllErrors() []error { return m }

// ReflectionRelationValidationError is the validation error returned by
// ReflectionRelation.Validate if the designated constraints aren't met.
type ReflectionRelationValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ReflectionRelationValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ReflectionRelationValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ReflectionRelationValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ReflectionRelationValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ReflectionRelationValidationError) ErrorName() string {
	return "ReflectionRelationValidationError"
}

// Error satisfies the builtin error interface
func (e ReflectionRelationValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sReflectionRelation.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ReflectionRelationValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ReflectionRelationValidationError{}

// Validate checks the field values on ReflectionTypeReference with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ReflectionTypeReference) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ReflectionTypeReference with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ReflectionTypeReferenceMultiError, or nil if none found.
func (m *ReflectionTypeReference) ValidateAll() error {
	return m.validate(true)
}

func (m *ReflectionTypeReference) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for SubjectDefinitionName

	// no validation rules for OptionalCaveatName

	switch v := m.Typeref.(type) {
	case *ReflectionTypeReference_IsTerminalSubject:
		if v == nil {
			err := ReflectionTypeReferenceValidationError{
				field:  "Typeref",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		// no validation rules for IsTerminalSubject
	case *ReflectionTypeReference_OptionalRelationName:
		if v == nil {
			err := ReflectionTypeReferenceValidationError{
				field:  "Typeref",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		// no validation rules for OptionalRelationName
	case *ReflectionTypeReference_IsPublicWildcard:
		if v == nil {
			err := ReflectionTypeReferenceValidationError{
				field:  "Typeref",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		// no validation rules for IsPublicWildcard
	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return ReflectionTypeReferenceMultiError(errors)
	}

	return nil
}

// ReflectionTypeReferenceMultiError is an error wrapping multiple validation
// errors returned by ReflectionTypeReference.ValidateAll() if the designated
// constraints aren't met.
type ReflectionTypeReferenceMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ReflectionTypeReferenceMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ReflectionTypeReferenceMultiError) AllErrors() []error { return m }

// ReflectionTypeReferenceValidationError is the validation error returned by
// ReflectionTypeReference.Validate if the designated constraints aren't met.
type ReflectionTypeReferenceValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ReflectionTypeReferenceValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ReflectionTypeReferenceValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ReflectionTypeReferenceValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ReflectionTypeReferenceValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ReflectionTypeReferenceValidationError) ErrorName() string {
	return "ReflectionTypeReferenceValidationError"
}

// Error satisfies the builtin error interface
func (e ReflectionTypeReferenceValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sReflectionTypeReference.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ReflectionTypeReferenceValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ReflectionTypeReferenceValidationError{}

// Validate checks the field values on ReflectionPermission with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ReflectionPermission) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ReflectionPermission with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ReflectionPermissionMultiError, or nil if none found.
func (m *ReflectionPermission) ValidateAll() error {
	return m.validate(true)
}

func (m *ReflectionPermission) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	// no validation rules for Comment

	// no validation rules for ParentDefinitionName

	if len(errors) > 0 {
		return ReflectionPermissionMultiError(errors)
	}

	return nil
}

// ReflectionPermissionMultiError is an error wrapping multiple validation
// errors returned by ReflectionPermission.ValidateAll() if the designated
// constraints aren't met.
type ReflectionPermissionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ReflectionPermissionMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ReflectionPermissionMultiError) AllErrors() []error { return m }

// ReflectionPermissionValidationError is the validation error returned by
// ReflectionPermission.Validate if the designated constraints aren't met.
type ReflectionPermissionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ReflectionPermissionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ReflectionPermissionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ReflectionPermissionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ReflectionPermissionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ReflectionPermissionValidationError) ErrorName() string {
	return "ReflectionPermissionValidationError"
}

// Error satisfies the builtin error interface
func (e ReflectionPermissionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sReflectionPermission.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ReflectionPermissionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ReflectionPermissionValidationError{}

// Validate checks the field values on ComputablePermissionsRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ComputablePermissionsRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ComputablePermissionsRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ComputablePermissionsRequestMultiError, or nil if none found.
func (m *ComputablePermissionsRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ComputablePermissionsRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetConsistency()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ComputablePermissionsRequestValidationError{
					field:  "Consistency",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ComputablePermissionsRequestValidationError{
					field:  "Consistency",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetConsistency()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ComputablePermissionsRequestValidationError{
				field:  "Consistency",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for DefinitionName

	// no validation rules for RelationName

	// no validation rules for OptionalDefinitionNameFilter

	if len(errors) > 0 {
		return ComputablePermissionsRequestMultiError(errors)
	}

	return nil
}

// ComputablePermissionsRequestMultiError is an error wrapping multiple
// validation errors returned by ComputablePermissionsRequest.ValidateAll() if
// the designated constraints aren't met.
type ComputablePermissionsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ComputablePermissionsRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ComputablePermissionsRequestMultiError) AllErrors() []error { return m }

// ComputablePermissionsRequestValidationError is the validation error returned
// by ComputablePermissionsRequest.Validate if the designated constraints
// aren't met.
type ComputablePermissionsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ComputablePermissionsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ComputablePermissionsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ComputablePermissionsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ComputablePermissionsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ComputablePermissionsRequestValidationError) ErrorName() string {
	return "ComputablePermissionsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ComputablePermissionsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sComputablePermissionsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ComputablePermissionsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ComputablePermissionsRequestValidationError{}

// Validate checks the field values on ReflectionRelationReference with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ReflectionRelationReference) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ReflectionRelationReference with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ReflectionRelationReferenceMultiError, or nil if none found.
func (m *ReflectionRelationReference) ValidateAll() error {
	return m.validate(true)
}

func (m *ReflectionRelationReference) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for DefinitionName

	// no validation rules for RelationName

	// no validation rules for IsPermission

	if len(errors) > 0 {
		return ReflectionRelationReferenceMultiError(errors)
	}

	return nil
}

// ReflectionRelationReferenceMultiError is an error wrapping multiple
// validation errors returned by ReflectionRelationReference.ValidateAll() if
// the designated constraints aren't met.
type ReflectionRelationReferenceMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ReflectionRelationReferenceMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ReflectionRelationReferenceMultiError) AllErrors() []error { return m }

// ReflectionRelationReferenceValidationError is the validation error returned
// by ReflectionRelationReference.Validate if the designated constraints
// aren't met.
type ReflectionRelationReferenceValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ReflectionRelationReferenceValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ReflectionRelationReferenceValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ReflectionRelationReferenceValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ReflectionRelationReferenceValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ReflectionRelationReferenceValidationError) ErrorName() string {
	return "ReflectionRelationReferenceValidationError"
}

// Error satisfies the builtin error interface
func (e ReflectionRelationReferenceValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sReflectionRelationReference.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ReflectionRelationReferenceValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ReflectionRelationReferenceValidationError{}

// Validate checks the field values on ComputablePermissionsResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ComputablePermissionsResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ComputablePermissionsResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// ComputablePermissionsResponseMultiError, or nil if none found.
func (m *ComputablePermissionsResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ComputablePermissionsResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetPermissions() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ComputablePermissionsResponseValidationError{
						field:  fmt.Sprintf("Permissions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ComputablePermissionsResponseValidationError{
						field:  fmt.Sprintf("Permissions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ComputablePermissionsResponseValidationError{
					field:  fmt.Sprintf("Permissions[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetReadAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ComputablePermissionsResponseValidationError{
					field:  "ReadAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ComputablePermissionsResponseValidationError{
					field:  "ReadAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetReadAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ComputablePermissionsResponseValidationError{
				field:  "ReadAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ComputablePermissionsResponseMultiError(errors)
	}

	return nil
}

// ComputablePermissionsResponseMultiError is an error wrapping multiple
// validation errors returned by ComputablePermissionsResponse.ValidateAll()
// if the designated constraints aren't met.
type ComputablePermissionsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ComputablePermissionsResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ComputablePermissionsResponseMultiError) AllErrors() []error { return m }

// ComputablePermissionsResponseValidationError is the validation error
// returned by ComputablePermissionsResponse.Validate if the designated
// constraints aren't met.
type ComputablePermissionsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ComputablePermissionsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ComputablePermissionsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ComputablePermissionsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ComputablePermissionsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ComputablePermissionsResponseValidationError) ErrorName() string {
	return "ComputablePermissionsResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ComputablePermissionsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sComputablePermissionsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ComputablePermissionsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ComputablePermissionsResponseValidationError{}

// Validate checks the field values on DependentRelationsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DependentRelationsRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DependentRelationsRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DependentRelationsRequestMultiError, or nil if none found.
func (m *DependentRelationsRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *DependentRelationsRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetConsistency()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DependentRelationsRequestValidationError{
					field:  "Consistency",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DependentRelationsRequestValidationError{
					field:  "Consistency",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetConsistency()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DependentRelationsRequestValidationError{
				field:  "Consistency",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for DefinitionName

	// no validation rules for PermissionName

	if len(errors) > 0 {
		return DependentRelationsRequestMultiError(errors)
	}

	return nil
}

// DependentRelationsRequestMultiError is an error wrapping multiple validation
// errors returned by DependentRelationsRequest.ValidateAll() if the
// designated constraints aren't met.
type DependentRelationsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DependentRelationsRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DependentRelationsRequestMultiError) AllErrors() []error { return m }

// DependentRelationsRequestValidationError is the validation error returned by
// DependentRelationsRequest.Validate if the designated constraints aren't met.
type DependentRelationsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DependentRelationsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DependentRelationsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DependentRelationsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DependentRelationsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DependentRelationsRequestValidationError) ErrorName() string {
	return "DependentRelationsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e DependentRelationsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDependentRelationsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DependentRelationsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DependentRelationsRequestValidationError{}

// Validate checks the field values on DependentRelationsResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DependentRelationsResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DependentRelationsResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DependentRelationsResponseMultiError, or nil if none found.
func (m *DependentRelationsResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *DependentRelationsResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetRelations() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, DependentRelationsResponseValidationError{
						field:  fmt.Sprintf("Relations[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, DependentRelationsResponseValidationError{
						field:  fmt.Sprintf("Relations[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return DependentRelationsResponseValidationError{
					field:  fmt.Sprintf("Relations[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetReadAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DependentRelationsResponseValidationError{
					field:  "ReadAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DependentRelationsResponseValidationError{
					field:  "ReadAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetReadAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DependentRelationsResponseValidationError{
				field:  "ReadAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return DependentRelationsResponseMultiError(errors)
	}

	return nil
}

// DependentRelationsResponseMultiError is an error wrapping multiple
// validation errors returned by DependentRelationsResponse.ValidateAll() if
// the designated constraints aren't met.
type DependentRelationsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DependentRelationsResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DependentRelationsResponseMultiError) AllErrors() []error { return m }

// DependentRelationsResponseValidationError is the validation error returned
// by DependentRelationsResponse.Validate if the designated constraints aren't met.
type DependentRelationsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DependentRelationsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DependentRelationsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DependentRelationsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DependentRelationsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DependentRelationsResponseValidationError) ErrorName() string {
	return "DependentRelationsResponseValidationError"
}

// Error satisfies the builtin error interface
func (e DependentRelationsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDependentRelationsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DependentRelationsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DependentRelationsResponseValidationError{}

// Validate checks the field values on DiffSchemaRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *DiffSchemaRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DiffSchemaRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DiffSchemaRequestMultiError, or nil if none found.
func (m *DiffSchemaRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *DiffSchemaRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetConsistency()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DiffSchemaRequestValidationError{
					field:  "Consistency",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DiffSchemaRequestValidationError{
					field:  "Consistency",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetConsistency()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DiffSchemaRequestValidationError{
				field:  "Consistency",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for ComparisonSchema

	if len(errors) > 0 {
		return DiffSchemaRequestMultiError(errors)
	}

	return nil
}

// DiffSchemaRequestMultiError is an error wrapping multiple validation errors
// returned by DiffSchemaRequest.ValidateAll() if the designated constraints
// aren't met.
type DiffSchemaRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DiffSchemaRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DiffSchemaRequestMultiError) AllErrors() []error { return m }

// DiffSchemaRequestValidationError is the validation error returned by
// DiffSchemaRequest.Validate if the designated constraints aren't met.
type DiffSchemaRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DiffSchemaRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DiffSchemaRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DiffSchemaRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DiffSchemaRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DiffSchemaRequestValidationError) ErrorName() string {
	return "DiffSchemaRequestValidationError"
}

// Error satisfies the builtin error interface
func (e DiffSchemaRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDiffSchemaRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DiffSchemaRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DiffSchemaRequestValidationError{}

// Validate checks the field values on DiffSchemaResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DiffSchemaResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DiffSchemaResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DiffSchemaResponseMultiError, or nil if none found.
func (m *DiffSchemaResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *DiffSchemaResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetDiffs() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, DiffSchemaResponseValidationError{
						field:  fmt.Sprintf("Diffs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, DiffSchemaResponseValidationError{
						field:  fmt.Sprintf("Diffs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return DiffSchemaResponseValidationError{
					field:  fmt.Sprintf("Diffs[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetReadAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DiffSchemaResponseValidationError{
					field:  "ReadAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DiffSchemaResponseValidationError{
					field:  "ReadAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetReadAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DiffSchemaResponseValidationError{
				field:  "ReadAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return DiffSchemaResponseMultiError(errors)
	}

	return nil
}

// DiffSchemaResponseMultiError is an error wrapping multiple validation errors
// returned by DiffSchemaResponse.ValidateAll() if the designated constraints
// aren't met.
type DiffSchemaResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DiffSchemaResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DiffSchemaResponseMultiError) AllErrors() []error { return m }

// DiffSchemaResponseValidationError is the validation error returned by
// DiffSchemaResponse.Validate if the designated constraints aren't met.
type DiffSchemaResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DiffSchemaResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DiffSchemaResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DiffSchemaResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DiffSchemaResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DiffSchemaResponseValidationError) ErrorName() string {
	return "DiffSchemaResponseValidationError"
}

// Error satisfies the builtin error interface
func (e DiffSchemaResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDiffSchemaResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DiffSchemaResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DiffSchemaResponseValidationError{}

// Validate checks the field values on ReflectionRelationSubjectTypeChange with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *ReflectionRelationSubjectTypeChange) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ReflectionRelationSubjectTypeChange
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// ReflectionRelationSubjectTypeChangeMultiError, or nil if none found.
func (m *ReflectionRelationSubjectTypeChange) ValidateAll() error {
	return m.validate(true)
}

func (m *ReflectionRelationSubjectTypeChange) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetRelation()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ReflectionRelationSubjectTypeChangeValidationError{
					field:  "Relation",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ReflectionRelationSubjectTypeChangeValidationError{
					field:  "Relation",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRelation()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ReflectionRelationSubjectTypeChangeValidationError{
				field:  "Relation",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetChangedSubjectType()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ReflectionRelationSubjectTypeChangeValidationError{
					field:  "ChangedSubjectType",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ReflectionRelationSubjectTypeChangeValidationError{
					field:  "ChangedSubjectType",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetChangedSubjectType()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ReflectionRelationSubjectTypeChangeValidationError{
				field:  "ChangedSubjectType",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ReflectionRelationSubjectTypeChangeMultiError(errors)
	}

	return nil
}

// ReflectionRelationSubjectTypeChangeMultiError is an error wrapping multiple
// validation errors returned by
// ReflectionRelationSubjectTypeChange.ValidateAll() if the designated
// constraints aren't met.
type ReflectionRelationSubjectTypeChangeMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ReflectionRelationSubjectTypeChangeMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ReflectionRelationSubjectTypeChangeMultiError) AllErrors() []error { return m }

// ReflectionRelationSubjectTypeChangeValidationError is the validation error
// returned by ReflectionRelationSubjectTypeChange.Validate if the designated
// constraints aren't met.
type ReflectionRelationSubjectTypeChangeValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ReflectionRelationSubjectTypeChangeValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ReflectionRelationSubjectTypeChangeValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ReflectionRelationSubjectTypeChangeValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ReflectionRelationSubjectTypeChangeValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ReflectionRelationSubjectTypeChangeValidationError) ErrorName() string {
	return "ReflectionRelationSubjectTypeChangeValidationError"
}

// Error satisfies the builtin error interface
func (e ReflectionRelationSubjectTypeChangeValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sReflectionRelationSubjectTypeChange.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ReflectionRelationSubjectTypeChangeValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ReflectionRelationSubjectTypeChangeValidationError{}

// Validate checks the field values on ReflectionCaveatParameterTypeChange with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *ReflectionCaveatParameterTypeChange) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ReflectionCaveatParameterTypeChange
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// ReflectionCaveatParameterTypeChangeMultiError, or nil if none found.
func (m *ReflectionCaveatParameterTypeChange) ValidateAll() error {
	return m.validate(true)
}

func (m *ReflectionCaveatParameterTypeChange) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetParameter()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ReflectionCaveatParameterTypeChangeValidationError{
					field:  "Parameter",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ReflectionCaveatParameterTypeChangeValidationError{
					field:  "Parameter",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetParameter()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ReflectionCaveatParameterTypeChangeValidationError{
				field:  "Parameter",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for PreviousType

	if len(errors) > 0 {
		return ReflectionCaveatParameterTypeChangeMultiError(errors)
	}

	return nil
}

// ReflectionCaveatParameterTypeChangeMultiError is an error wrapping multiple
// validation errors returned by
// ReflectionCaveatParameterTypeChange.ValidateAll() if the designated
// constraints aren't met.
type ReflectionCaveatParameterTypeChangeMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ReflectionCaveatParameterTypeChangeMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ReflectionCaveatParameterTypeChangeMultiError) AllErrors() []error { return m }

// ReflectionCaveatParameterTypeChangeValidationError is the validation error
// returned by ReflectionCaveatParameterTypeChange.Validate if the designated
// constraints aren't met.
type ReflectionCaveatParameterTypeChangeValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ReflectionCaveatParameterTypeChangeValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ReflectionCaveatParameterTypeChangeValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ReflectionCaveatParameterTypeChangeValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ReflectionCaveatParameterTypeChangeValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ReflectionCaveatParameterTypeChangeValidationError) ErrorName() string {
	return "ReflectionCaveatParameterTypeChangeValidationError"
}

// Error satisfies the builtin error interface
func (e ReflectionCaveatParameterTypeChangeValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sReflectionCaveatParameterTypeChange.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ReflectionCaveatParameterTypeChangeValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ReflectionCaveatParameterTypeChangeValidationError{}

// Validate checks the field values on ReflectionSchemaDiff with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ReflectionSchemaDiff) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ReflectionSchemaDiff with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ReflectionSchemaDiffMultiError, or nil if none found.
func (m *ReflectionSchemaDiff) ValidateAll() error {
	return m.validate(true)
}

func (m *ReflectionSchemaDiff) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	switch v := m.Diff.(type) {
	case *ReflectionSchemaDiff_DefinitionAdded:
		if v == nil {
			err := ReflectionSchemaDiffValidationError{
				field:  "Diff",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetDefinitionAdded()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ReflectionSchemaDiffValidationError{
						field:  "DefinitionAdded",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ReflectionSchemaDiffValidationError{
						field:  "DefinitionAdded",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetDefinitionAdded()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ReflectionSchemaDiffValidationError{
					field:  "DefinitionAdded",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ReflectionSchemaDiff_DefinitionRemoved:
		if v == nil {
			err := ReflectionSchemaDiffValidationError{
				field:  "Diff",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetDefinitionRemoved()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ReflectionSchemaDiffValidationError{
						field:  "DefinitionRemoved",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ReflectionSchemaDiffValidationError{
						field:  "DefinitionRemoved",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetDefinitionRemoved()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ReflectionSchemaDiffValidationError{
					field:  "DefinitionRemoved",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ReflectionSchemaDiff_DefinitionDocCommentChanged:
		if v == nil {
			err := ReflectionSchemaDiffValidationError{
				field:  "Diff",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetDefinitionDocCommentChanged()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ReflectionSchemaDiffValidationError{
						field:  "DefinitionDocCommentChanged",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ReflectionSchemaDiffValidationError{
						field:  "DefinitionDocCommentChanged",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetDefinitionDocCommentChanged()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ReflectionSchemaDiffValidationError{
					field:  "DefinitionDocCommentChanged",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ReflectionSchemaDiff_RelationAdded:
		if v == nil {
			err := ReflectionSchemaDiffValidationError{
				field:  "Diff",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetRelationAdded()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ReflectionSchemaDiffValidationError{
						field:  "RelationAdded",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ReflectionSchemaDiffValidationError{
						field:  "RelationAdded",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetRelationAdded()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ReflectionSchemaDiffValidationError{
					field:  "RelationAdded",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ReflectionSchemaDiff_RelationRemoved:
		if v == nil {
			err := ReflectionSchemaDiffValidationError{
				field:  "Diff",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetRelationRemoved()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ReflectionSchemaDiffValidationError{
						field:  "RelationRemoved",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ReflectionSchemaDiffValidationError{
						field:  "RelationRemoved",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetRelationRemoved()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ReflectionSchemaDiffValidationError{
					field:  "RelationRemoved",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ReflectionSchemaDiff_RelationDocCommentChanged:
		if v == nil {
			err := ReflectionSchemaDiffValidationError{
				field:  "Diff",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetRelationDocCommentChanged()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ReflectionSchemaDiffValidationError{
						field:  "RelationDocCommentChanged",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ReflectionSchemaDiffValidationError{
						field:  "RelationDocCommentChanged",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetRelationDocCommentChanged()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ReflectionSchemaDiffValidationError{
					field:  "RelationDocCommentChanged",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ReflectionSchemaDiff_RelationSubjectTypeAdded:
		if v == nil {
			err := ReflectionSchemaDiffValidationError{
				field:  "Diff",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetRelationSubjectTypeAdded()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ReflectionSchemaDiffValidationError{
						field:  "RelationSubjectTypeAdded",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ReflectionSchemaDiffValidationError{
						field:  "RelationSubjectTypeAdded",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetRelationSubjectTypeAdded()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ReflectionSchemaDiffValidationError{
					field:  "RelationSubjectTypeAdded",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ReflectionSchemaDiff_RelationSubjectTypeRemoved:
		if v == nil {
			err := ReflectionSchemaDiffValidationError{
				field:  "Diff",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetRelationSubjectTypeRemoved()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ReflectionSchemaDiffValidationError{
						field:  "RelationSubjectTypeRemoved",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ReflectionSchemaDiffValidationError{
						field:  "RelationSubjectTypeRemoved",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetRelationSubjectTypeRemoved()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ReflectionSchemaDiffValidationError{
					field:  "RelationSubjectTypeRemoved",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ReflectionSchemaDiff_PermissionAdded:
		if v == nil {
			err := ReflectionSchemaDiffValidationError{
				field:  "Diff",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetPermissionAdded()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ReflectionSchemaDiffValidationError{
						field:  "PermissionAdded",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ReflectionSchemaDiffValidationError{
						field:  "PermissionAdded",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetPermissionAdded()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ReflectionSchemaDiffValidationError{
					field:  "PermissionAdded",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ReflectionSchemaDiff_PermissionRemoved:
		if v == nil {
			err := ReflectionSchemaDiffValidationError{
				field:  "Diff",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetPermissionRemoved()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ReflectionSchemaDiffValidationError{
						field:  "PermissionRemoved",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ReflectionSchemaDiffValidationError{
						field:  "PermissionRemoved",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetPermissionRemoved()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ReflectionSchemaDiffValidationError{
					field:  "PermissionRemoved",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ReflectionSchemaDiff_PermissionDocCommentChanged:
		if v == nil {
			err := ReflectionSchemaDiffValidationError{
				field:  "Diff",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetPermissionDocCommentChanged()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ReflectionSchemaDiffValidationError{
						field:  "PermissionDocCommentChanged",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ReflectionSchemaDiffValidationError{
						field:  "PermissionDocCommentChanged",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetPermissionDocCommentChanged()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ReflectionSchemaDiffValidationError{
					field:  "PermissionDocCommentChanged",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ReflectionSchemaDiff_PermissionExprChanged:
		if v == nil {
			err := ReflectionSchemaDiffValidationError{
				field:  "Diff",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetPermissionExprChanged()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ReflectionSchemaDiffValidationError{
						field:  "PermissionExprChanged",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ReflectionSchemaDiffValidationError{
						field:  "PermissionExprChanged",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetPermissionExprChanged()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ReflectionSchemaDiffValidationError{
					field:  "PermissionExprChanged",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ReflectionSchemaDiff_CaveatAdded:
		if v == nil {
			err := ReflectionSchemaDiffValidationError{
				field:  "Diff",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetCaveatAdded()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ReflectionSchemaDiffValidationError{
						field:  "CaveatAdded",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ReflectionSchemaDiffValidationError{
						field:  "CaveatAdded",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetCaveatAdded()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ReflectionSchemaDiffValidationError{
					field:  "CaveatAdded",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ReflectionSchemaDiff_CaveatRemoved:
		if v == nil {
			err := ReflectionSchemaDiffValidationError{
				field:  "Diff",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetCaveatRemoved()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ReflectionSchemaDiffValidationError{
						field:  "CaveatRemoved",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ReflectionSchemaDiffValidationError{
						field:  "CaveatRemoved",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetCaveatRemoved()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ReflectionSchemaDiffValidationError{
					field:  "CaveatRemoved",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ReflectionSchemaDiff_CaveatDocCommentChanged:
		if v == nil {
			err := ReflectionSchemaDiffValidationError{
				field:  "Diff",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetCaveatDocCommentChanged()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ReflectionSchemaDiffValidationError{
						field:  "CaveatDocCommentChanged",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ReflectionSchemaDiffValidationError{
						field:  "CaveatDocCommentChanged",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetCaveatDocCommentChanged()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ReflectionSchemaDiffValidationError{
					field:  "CaveatDocCommentChanged",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ReflectionSchemaDiff_CaveatExprChanged:
		if v == nil {
			err := ReflectionSchemaDiffValidationError{
				field:  "Diff",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetCaveatExprChanged()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ReflectionSchemaDiffValidationError{
						field:  "CaveatExprChanged",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ReflectionSchemaDiffValidationError{
						field:  "CaveatExprChanged",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetCaveatExprChanged()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ReflectionSchemaDiffValidationError{
					field:  "CaveatExprChanged",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ReflectionSchemaDiff_CaveatParameterAdded:
		if v == nil {
			err := ReflectionSchemaDiffValidationError{
				field:  "Diff",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetCaveatParameterAdded()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ReflectionSchemaDiffValidationError{
						field:  "CaveatParameterAdded",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ReflectionSchemaDiffValidationError{
						field:  "CaveatParameterAdded",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetCaveatParameterAdded()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ReflectionSchemaDiffValidationError{
					field:  "CaveatParameterAdded",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ReflectionSchemaDiff_CaveatParameterRemoved:
		if v == nil {
			err := ReflectionSchemaDiffValidationError{
				field:  "Diff",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetCaveatParameterRemoved()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ReflectionSchemaDiffValidationError{
						field:  "CaveatParameterRemoved",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ReflectionSchemaDiffValidationError{
						field:  "CaveatParameterRemoved",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetCaveatParameterRemoved()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ReflectionSchemaDiffValidationError{
					field:  "CaveatParameterRemoved",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ReflectionSchemaDiff_CaveatParameterTypeChanged:
		if v == nil {
			err := ReflectionSchemaDiffValidationError{
				field:  "Diff",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetCaveatParameterTypeChanged()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ReflectionSchemaDiffValidationError{
						field:  "CaveatParameterTypeChanged",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ReflectionSchemaDiffValidationError{
						field:  "CaveatParameterTypeChanged",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetCaveatParameterTypeChanged()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ReflectionSchemaDiffValidationError{
					field:  "CaveatParameterTypeChanged",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return ReflectionSchemaDiffMultiError(errors)
	}

	return nil
}

// ReflectionSchemaDiffMultiError is an error wrapping multiple validation
// errors returned by ReflectionSchemaDiff.ValidateAll() if the designated
// constraints aren't met.
type ReflectionSchemaDiffMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ReflectionSchemaDiffMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ReflectionSchemaDiffMultiError) AllErrors() []error { return m }

// ReflectionSchemaDiffValidationError is the validation error returned by
// ReflectionSchemaDiff.Validate if the designated constraints aren't met.
type ReflectionSchemaDiffValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ReflectionSchemaDiffValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ReflectionSchemaDiffValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ReflectionSchemaDiffValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ReflectionSchemaDiffValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ReflectionSchemaDiffValidationError) ErrorName() string {
	return "ReflectionSchemaDiffValidationError"
}

// Error satisfies the builtin error interface
func (e ReflectionSchemaDiffValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sReflectionSchemaDiff.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ReflectionSchemaDiffValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ReflectionSchemaDiffValidationError{}
